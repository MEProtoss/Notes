# JavaScript

## 事件的触发

### js代码的执行顺序是从逐行解释执行

## BOM编程 Browser Object Model

- window 对象调用方法的时候 可以省略`window.`

## DOM 编程 document object model

> dom编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程.

- document对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。
- 根据HTML代码结构特点,document对象本身是一种**树形结构**的文档对象。

## 正则表达式

> 正则表达式是描述字符模式的对象。正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。

## xml

## Servlet

> Servlet (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范; 从代码层面上来讲Servlet就是一个`接口`

## Vue3视图渲染技术

### 条件渲染和列表渲染

### 条件渲染

- v-if
- v-else
- v-show

> **`v-if`** **vs** **`v-show`**

- `v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。
- `v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。
- 相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。
- 总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。

### 列表渲染

### 双向绑定

### 属性计算

- 通过计算属性获得数据

  > 计算属性缓存 vs 方法

- 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果!

### 数据监听器

watch主要用于以下场景：

- 当数据发生变化时需要执行相应的操作
- 监听数据变化，当满足一定条件时触发相应操作
- 在异步操作前或操作后需要执行相应的操作

## Vue组件

- 用多个.vue文件拼接出一个页面
- 在app.vue 中引入components文件夹中的各个组件

### 组件之间的参数传递（用的不多）

- 参数的父传子

- 参数的子传父

- 兄弟传参

## Vue3路由机制(页面切换)

### 7.1 路由简介

> 1 什么是路由？

- 定义：路由就是根据不同的 URL 地址展示不同的内容或页面。
- 通俗理解：路由就像是一个地图，我们要去不同的地方，需要通过不同的路线进行导航。

> 2 路由的作用

- 单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验；
- 路由还可以实现页面的认证和权限控制，保护用户的隐私和安全；
- 路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面。

### 路由的重定向

> 重定向的作用：将一个路由重定向到另一个路由上

- 修改案例：访问/list和/showAll都定向到List.vue
- router.js

### 编程式路由(useRouter)

### 路由传参（useRoute)

## Vue3 数据交互axios

### promise

#### 普通函数和回调函数

> 普通函数: 正常调用的函数,一般函数执行完毕后才会继续执行下一行代码

> 回调函数: 一些特殊的函数,表示未来才会执行的一些功能,后续代码不会等待该函数执行完毕就开始执行了

#### Promise catch()

> `Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

#### async和await的使用（帮助使用更简洁的语法获得一个promise对象）

> &#x20;async和await是ES6中用于处理异步操作的新特性。通常，异步操作会涉及到Promise对象，而async/await则是在Promise基础上提供了更加直观和易于使用的语法。

> async 用于标识函数的

1. async标识函数后,async函数的返回值会变成一个promise对象

2. 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象

3. 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定

4. 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象

```html
/* async 用于标识函数的 1.
async标识函数后,async函数的返回值会变成一个promise对象 2.
如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态
promise对象 3.
如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定 4.
如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象 */
```

> await 帮助获取promise成功状态的返回值的关键字

1. await右侧的表达式一般为一个promise对象,但是也可以是一个其他值
2. 如果表达式是promise对象,await返回的是promise成功的值
3. await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行
4. 如果表达式是其他值,则直接返回该值
5. await必须在async函数中,但是async函数中可以没有await
6. 如果await右边的promise失败了,就会抛出异常,需要通过 try ... catch捕获处理
