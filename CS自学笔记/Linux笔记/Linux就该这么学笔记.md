2023/04/25 15:57:04

# 第2章新手必须掌握的linux命令

## 2.1 shell

用户终端程序 bash :Bourne-Again SHell 是shell的一种

## 2.2 执行命令必备的基础知识

### 命令格式： 命令v + [参数]adj/adv + 对象o

其中命令参数有长格式和短格式：
```bash
man -h
man -help
```

### 四个快捷键技巧

| shortcuts | function     |
| --------- | ------------ |
| ctrl c    | 终止进程     |
| ctrl d    | 键盘输入结束 |
| ctrl l    | 清屏         |
| tab       | 补全         |

## 2.3 常用系统工作命令

1. echo

- 用于在终端设备上输出字符串或变量提取后的值:echo [字符串][$变量]
其中**$符号的意思是提取变量的实际值**

```bash
echo $SHELL
```

2. date

- 用于显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”

3. timedatectl

- 命令用于设置系统的时间，英文全称为“time date control”，语法格式为 “timedatectl
[参数

4. reboot

5. poweroff

- 关闭系统

6. wget

- 用于终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数]
网址”

7. ps

- 用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参 数]

```bash
ps -a
ps -u
ps -x
```

- linux系统中的五种常见状态

* [ ] R 运行进程正在运行或在运行队列中等待。
* [ ] S 中断 进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态
* [ ] D 不可中断。进程不响应系统异步信号，即便用 kill 命令也不能将其中断。
* [ ] Z 僵死。进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数
后将进程释放。
* [ ] T 停止。进程收到停止信号后停止运行。

8. pstree

- pstree 命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”

9. tops

- 动态地监视进程活动及系统负载等信息

10. nice

- 调整进程的优先级。语法格式为“nice 优先级数字 服务名称”在 top
命令输出的结果中，PR 和 NI 值代表的是进程的优先级，数字越低（取值范围是
-20～19），优先级越高

```bash
nice -n -20 bash
```

11. pidof

- pidof 命令用于查询某个指定服务进程的 PID 号码值，语法格式为“pidof [参数]
服务名称”

12. kill

- kill 命令用于终止某个指定 PID 值的服务进程，语法格式为“kill [参数] 进程的 PID”

```bash
kill -9 2156 #有时进程无法被终止，可使用-9表示最高级别的强制杀死
```

13. killall

- killall 命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall
[参数] 服 务名称”。

## 2.4 系统状态检测命令

1. ifconfig

- 命令用于获取网卡配置与网络状态等信息，英文全称为“interface config”，语法
格式为“ifconfig [参数] [网络设备]”

2. unname

- 用于查看系统内核版本与系统架构等信息，英文全称为“unix name”，语法格 式为“uname
[-a]”。

3. uptime

- uptime 命令用于查看系统的负载信息，输入该命令后按回车键执行即可。 uptime
命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及
平均负载值等信息。平均负载值指的是系统在最近 1 分钟、5 分钟、15
分钟内的压力情况（下 面加粗的信息部分），负载值越低越好 parameter | function |
| ---- | ----- | | -a | 显示所有连接中的 Socket | | -p | 显示正在使用的 Socket
信息 | | -t | 显示 TCP 协议的连接状态 |

4. free

- 用于显示当前系统中内存的使用量信息，语法格式为“free [-h]”

5. who

- who 命令用于查看当前登入主机的用户终端信息

6. last

- last 命令用于调取主机的被访记录

7. ping

- ping 命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”

| parameter | function        |
| --------- | --------------- |
| -c        | 发送次数        |
| -l        | 指定网卡名称    |
| -I        | 每次间隔时间(s) |
| -W        | 最长等待时间(s) |

8. tracepath

- tracepath 命令用于显示数据包到达目的主机时途中经过的所有路由信息，语法格式为
“tracepath [参数] 域名”。

当两台主机之间无法正常 ping 通时，要考虑两台主机之间是否有错误的路由信息，导致
数据被某一台设备错误地丢弃。这时便可以使用 tracepath
命令追踪数据包到达目的主机时途 中的所有路由信息

9. netstat

- etstat 命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为
“network status”，语法格式为“netstat [参数]”

10. history

- history 命令用于显示执行过的命令历史，语法格式为“history [-c]”

11. sosreport

- sosreport
命令用于收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可

## 查找定位文件命令

1. pwd

- 英文全称为“print working directory”

2. cd

- change directory

3. ls

- 用于显示目录中的文件信息，英文全称为“list”，语法格式为“ls [参数] [文件名称]”。
使用 ls 命令的-a 参数 可以看到全部文件（包括隐藏文件），使用-l
参数可以查看文件的属性、大小等详细信息

4. tree

- tree 命令用于以树状图的形式列出目录内容及结构

5. find

- find 命令用于按照指定条件来查找文件所对应的位置，语法格式为“find [查找范围] 寻
找条件”。 `Linux 系统中的一切都是文件` 在 Linux 系统中，搜索工作一般都是通过
find 命令来完成的，它可以使用不同的文件特性作
为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到
屏幕上

| parameter     | function                                                 |
| ------------- | -------------------------------------------------------- |
| -name         | 匹配名称                                                 |
| -perm         | 匹配权限（mode 为完全匹配，-mode 为包含即可）            |
| -user         | 匹配所有者                                               |
| -group        | 匹配所属组                                               |
| -mtime -n +n  | 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）     |
| -atime -n +n  | 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）     |
| -ctime -n +n  | 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前） |
| -nouser       | 匹配无所有者的文件                                       |
| -nogroup      | 匹配无所属组的文件                                       |
| -newer f1 !f2 | 匹配比文件 f1 新但比 f2 旧的文件                         |

|--type
b/d/c/p/l/f|匹配文件类型（后面的字母依次表示块设备、目录、字符设备、管道、链接
文件、文本文件）| |-size|匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB
为查找小于 50KB 的文件）| |-prune|忽略某个目录| |-exec......
{}\;|后面可跟用于进一步处理搜索结果的命令|

- 这里需要重点讲解-exec 参数的重要作用。这个参数用于把 find
命令搜索到的结果交由紧 随其后的命令作进一步处理。它十分类似于第 3
章将要讲解的管道符技术，并且由于 find 命 令对参数有特殊要求，因此虽然 exec
是长格式形式，但它的前面依然只需要一个减号（-）。

- **根据文件系统层次标准（Filesystem Hierarchy Standard）协议，Linux
系统中的配置文件 会保存到/etc 目录中**

- 如果要想获取该目录中所有以 host 开头的文件列表，可 以执行如下命令：

```bash
find /etc -name "host*"
```

- 如果要在整个系统中搜索权限中包括 SUID 权限的所有文件（详见第 5 章），只需使用
-4000 即可

```bash
find / -perm -4000 -print
```

进阶实验： 在整个文件系统中找出所有归属于 linuxprobe
用户的文件并复制到/root/findresults 目录中。 该实验的重点是“-exec {}
\;”参数，其中的{}表示 find 命令搜索出的每一个文件，并且
命令的结尾必须是“\;”。完成该实验的具体命令如下：

```bash
find / -user linuxprobe -exec cp -a {} /root/findresults/ \;
```

6. locate

- locate 命令用于按照名称快速搜索文件所对应的位置，语法格式为“locate 文件名称”。
使用 find 命令进行全盘搜索虽然更准确，但是效率有点低。如果仅仅是想找一些常见的
且又知道大概名称的文件，不如试试 locate 命令。在使用 locate 命令时，先使用
updateddb 命
令生成一个索引库文件，这个库文件的名字是/var/lib/mlocate/mlocate.db，后续在使用
locate 命令搜索文件时就是在该库中进行查找操作，速度会快很多
`但是有更好的工具fzf :smile`

7. whereis

- whereis
命令用于按照名称快速搜索二进制程序（`命令`）、`源代码以及帮助文件所对应的 位置`，语法格式为“whereis
命令名称”。 简单来说，whereis 命令也是基于 updatedb
命令所生成的索引库文件进行搜索，它与 locate
命令的区别是不关心那些相同名称的文件，仅仅是快速找到对应的命令文件及其帮助文件所
在的位置

8. which

- which 命令用于按照指定名称快速搜索二进制程序（`命令`）所对应的位置，语法格式为
“which 命令名称”。which 命令是在 PATH
变量所指定的路径中，按照指定条件搜索命令所在的路径。也就是
说，如果我们既不关心同名文件（find 与
locate），也不关心命令所对应的源代码和帮助文件
（whereis），仅仅是想找到命令本身所在的路径，那么这个 which 命令就太合适了

## 文本文件编辑命令

1. cat

- cat
命令用于查看纯文本文件（内容较少的），英文全称为“concatenate”，语法格式为“cat
[参数] 文件名称”,如果在查看文本内容时还想顺便显示行号的话，不妨在 cat
命令后面追加一个`-n` 参数

2. more

- more 命令用于查看纯文本文件（内容较多的），语法格式为“more [参数]
文件名称”,more
命令会在最下面使用百分比的形式来提示您已经阅读了多少内容；还可以使用空格键或回车
键向下翻页

3. head

- head 命令用于查看纯文本文件的前 N 行，语法格式为“head [参数] 文件名称”
如果只想 查看文本中前 10 行的内容

```bash
head -n 10 filename
```

4. tail

- tail 命令用于查看纯文本文件的后 N 行或持续刷新文件的最新内容，语法格式为“tail
[参 数] 文件名称”。与head类似
- tail
命令最强悍的功能是能够持续刷新一个文件的内容，当想要实时查看最新的日志文件
时，这特别有用，此时的命令格式为“tail -f 文件名称”：

```bash
tail -f filename
```

5. tr

- tr 命令用于替换文本内容中的字符，英文全称为“translate”，语法格式为“tr
[原始字符] [目标字符]”。
在很多时候，我们想要快速地替换文本中的一些词汇，又或者想把整个文本内容都进行
替换。如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替
换更是不现实。这时，就可以先使用 `cat`
命令读取待处理的文本，然后通过管道符（详见第 3 章）把这些文本内容传递给 tr
命令进行替换操作即可。例如，把某个文本内容中的英文全部 替换为大写：

```bash
cat filename | tr [a-z] [A-Z]
```

6. wc

- wc 命令用于统计指定文本文件的行数、字数或字节数，英文全称为“word counts”，语
法格式为“wc [参数] 文件名称”

| parameter | function     |
| --------- | ------------ |
| -l        | 只显示行数   |
| -w        | 只显示单词数 |
| -c        | 只显示字节数 |

- **在 Linux 系统中，/etc/passwd
是用于保存所有用户信息的文件**，要统计当前系统中有多
少个用户，可以使用下面的命令来进行查询:

```bash
wc -l /etc/passwd
```

7. stat

- stat
命令用于查看文件的具体存储细节和时间等信息，英文全称为“status”，语法格式为
“stat 文件名称”。
- 大家都知道，文件有一个修改时间。其实，除了修改时间之外，Linux 系统中的文件包
含 3 种时间状态，分别是 Access Time（内容最后一次被访问的时间，简称为
Atime），Modify Time（内容最后一次被修改的时间，简称为 Mtime）以及 Change
Time（文件属性最后一次被 修改的时间，简称为 Ctime)

8. grep

- grep 命令用于按行提取文本内容，语法格式为“grep [参数] 文件名称”。grep
命令是用途最广泛的文本搜索匹配工具

| parameter | function                                 |
| --------- | ---------------------------------------- |
| -n        | 显示搜索到的信息的行号                   |
| -v        | 反选信息（即没有包含关键词的所有信息行） |

- **在 Linux 系统中，/etc/passwd
文件保存着所有的用户信息，而一旦用户的登录终端被设
置成/sbin/nologin，则不再允许登录系统**，因此可以使用 grep
命令查找出当前系统中不允许登 录系统的所有用户的信息：

```bash
grep /sbin/nologin /etc/passwd
```

9. cut

- 用于按“列”提取文本内容，语法格式为“cut [参数]

文件名称”。系统文件在保存用户数据信息时，每一项值之间是采用冒号来间隔的，先查看一下：

```bash
head -n 2 /etc/passwd
```

一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键
词即可。但是如果按“列”搜索，不仅要使用-f 参数设置需要查看的列数，还需要使用-d 参
数来设置间隔符号。

接下来使用下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间
隔符号的第一列内容：

```bash
cut -d : -f 1 /etc/passwd
```

10. diff

- diff
命令用于比较多个文件之间内容的差异，英文全称为“different”，语法格式为“diff [参
数] 文件名称 A 文件名称 B”

- 在使用 diff 命令时，不仅可以使用--brief
参数来确认两个文件是否相同，还可以使用-c
参数来详细比较出多个文件的差异之处。这绝对是判断文件是否被篡改的有力神器。例如，
先使用 cat 命令分别查看 diff_A.txt 和 diff_B.txt 文件的内容，然后进行比较:

```bash
cat diff_A.text
cat diff_B.tx
```

接下来使用`diff --brief` 命令显示比较后的结果，判断文件是否相同

```bash
diff --brief diff_A.txt diff_B.txt
```

最后使用带有`-c`参数的 diff 命令来描述文件内容具体的不同

```bash
diff -c diff_A.txt diff_B.txt
```

11. uniq

- uniq 命令用于去除文本中**连续的**重复行，英文全称为“unique”，语法格式为“uniq
[参数] 文 件名称”

12. sort

- sort 命令用于对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。
- 有时文本中的内容顺序不正确，一行行地手动修改实在太麻烦了。此时使用 sort 命令就
再合适不过了，它能够对文本内容进行再次排序。这个命令千万不能只讲理论，一定要借助
于实战让大家一看就懂。sort 命令的参数及其作用如表 2-16 所示。

| parameter | function       |
| --------- | -------------- |
| -f        | 忽略大小写     |
| -b        | 忽略缩进与空格 |
| -n        | 以数值型排序   |
| -r        | 反向排序       |
| -u        | 去除重复行     |
| -t        | 指定间隔符     |
| -k        | 设置字符段范围 |

- 首先，在执行 sort 命令后默认会按照字母顺序进行排序，非常方便

- 此外，与 uniq 命令不同，sort
命令是无论内容行之间是否夹杂有其他内容，只要有两个
一模一样的内容行，立马就可以使用-u 参数进行去重操作

- 想对数字进行排序？一点问题都没有，而且完全不用担心出现 1 大于 20
这种问题（因为 有些命令只比较数字的第一位，忽略了十、百、千的位）

## 文件目录管理命令

1. touch

- touch 命令用于创建空白文件 或 设置文件的时间，语法格式为“touch [参数]
文件名称”。

| parameter | function                   |
| --------- | -------------------------- |
| -a        | 仅修改“访问时间”（Atime ） |
| -m        | 仅修改“修改时间”（Mtime ） |
| -d        | 同时修改上述两者           |

2. mkdir

- mkdir 命令用于创建空白的目录，英文全称为“make directory”，语法格式为“mkdir [参
数] 目录名称”。
- 除了能创建单个空白目录外，mkdir 命令还可以结合-p 参数来递归创建出具有嵌套层叠
关系的文件目录

3. cp

- cp 命令用于复制文件或目录，英文全称为“copy”，语法格式为“cp [参数] 源文件名称
  目 标文件名称”
- 在复制目录时要加上-r 参数,表示递归(recursion)

  4. mv

  - mv 命令用于剪切或重命名文件，英文全称为“move”，语法格式为“mv [参数] 源文件
  名称 目标文件名称”

  5. rm

  - rm 命令用于删除文件或目录，英文全称为“remove”，语法格式为“rm [参数] 文件
  名称”。
  - 在 Linux 系统中删除文件时，系统会默认向您询问是否要执行删除操作，如果不想总是
  看到这种反复的确认信息，可在 rm 命令后跟上-f
  参数来强制删除。另外，要想删除一个目录， 需要在 rm 命令后面加一个-r
  参数才可以，否则删除不掉。rm 命令的参数及其作用如表 2-19 所示。

  | parameter | function   |
  | --------- | ---------- |
  | -f        | 强制执行   |
  | -i        | 删除前询问 |
  | -r        | 删除目录   |
  | -v        | 显示过程   |

  6. dd

  - dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，语法格式为“dd if=
  参数值 of=参数值 count=参数值 bs=参数值”
  - dd 命令是一个比较重要而且比较有特色的命令，它能够让用户按照指定大小和个数的数
  据块来复制文件的内容。当然，如果愿意的话，还可以在复制过程中转换其中的数据。Linux
  系统中有一个名为/dev/zero 的设备文件，充满哲学理论的色彩。因
  为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此常常使用它作为
  dd 命令的输入文件，来生成一个指定大小的文件。dd 命令的参数及其作用如表 2-20
  所示。

  | Key   | Value                |
  | ----- | -------------------- |
  | if    | 输入的文件名称       |
  | of    | 输出的文件名称       |
  | bs    | 设置每个“块”的大小   |
  | count | 设置要复制“块”的个数 |

  例如，用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后保存成
  名为 560_file 的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：

  ```bash
  ```

  - dd 命令的功能也绝不仅限于复制文件这么简单。如果想把光驱设备中的光盘制作成 iso
  格式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux
  系统中可 以直接使用 dd 命令来压制出光盘镜像文件，将它变成一个可立即使用的 iso
  镜像:

  ```bash
  dd if=/dev/cdrom of=RHEL-server-8.0-x86_64-LinuxProbe.Com.iso
  ```

  7. file

  - file 命令用于查看文件的类型，语法格式为“file 文件名称”。
  - 在 Linux 系统中，由于文本、目录、设备等所有这些一切都统称为文件，但是它们又不
  像 Windows
  系统那样都有后缀，因此很难通过文件名一眼判断出具体的文件类型，这时就需 要使用
  file 命令来查看文件类型了。
  - 在 Windows 系统中打开文件时，一般是通过用户双击鼠标完成的，系统会自行判
  断用户双击的文件是什么类型，因此需要有后缀进行区别。而 Linux 系统则是根据用户
  执行的命令来调用文件，例如执行 cat 命令查看文本，执行 bash 命令执行脚本等，所
  以也就不需要强制让用户给文件设置后缀了。

  8. tar

  - tar 命令用于对文件进行打包压缩或解压，语法格式为“tar 参数 文件名称”

  | Key | Value                  |
  | --- | ---------------------- |
  | -c  | 创建压缩文件           |
  | -x  | 解开压缩文件           |
  | -t  | 查看压缩包内有哪些文件 |
  | -z  | 用 gzip 压缩或解压     |
  | -j  | 用 bzip2 压缩或解压    |
  | -v  | 显示压缩或解压的过程   |
  | -f  | 目标文件名             |
  | -p  | 保留原始的权限与属性   |
  | -P  | 使用绝对路径来压缩     |
  | -C  | 指定解压到的目录       |

  - 首先，-c 参数用于创建压缩文件，-x
  参数用于解压文件，因此这两个参数不能同时使用。
  - 其次，-z 参数指定使用 gzip 格式来压缩或解压文件，-j 参数指定使用 bzip2
  格式来压缩或解
  压文件。用户使用时则是根据文件的后缀来决定应使用何种格式的参数进行解压。在执行某
  些压缩或解压操作时，可能需要花费数个小时，如果屏幕一直没有输出，您一方面不好判断
  打包的进度情况，另一方面也会怀疑电脑死机了，因此非常推荐使用-v
  参数向用户不断显示 压缩或解压的过程。
  - -C 参数用于指定要解压到哪个指定的目录。-f 参数特别重要，它必须放
  到参数的最后一位，代表要压缩或解压的软件包名称。
  - 常用命令 `tar -czvf 压缩包名 称.tar.gz 要打包的目录`
  命令把指定的文件进行打包压缩;相应的解压命令为`tar -xzvf 压缩 包名称.tar.gz`

# 第3章 管道符、重定向与环境变量

## 3.1 输入输出重定向

  - 标准输入重定向(STDIN,文件描述符为0)：从键盘输入，也可从其他文件或命令输入
  - 标准输出重定向(STDOUT，文件描述符为1)：默认输出到屏幕。
  - 错误输出重定向(STDERR,文件描述符为2): 默认输出到屏幕。

                                          ---

                                          输入重定向用到的符号及作用 | 符号 | 作用 | |-|-| |命令 <
                                          文件|将文件作为命令的标准输入| |命令 <<
                                          分界符|从标准输入中读入，直到遇见分界符才停止| |命令 < 文件 1 > 文件 2|将文件 1
                                          作为命令的标准输入并将标准输出到文件 2|

                                          ---

                                          输出重定向中用到的符号及其作用 | 符号 | 作用 | |-|-| |命令 >
                                          文件|将标准输出重定向到一个文件中（`清空`原有文件的数据）| |命令 2>
                                          文件|将错误输出重定向到一个文件中（`清空`原有文件的数据）| |命令 >>
                                          文件|将标准输出重定向到一个文件中（`追加`到原有内容的后面） |命令 2>>
                                          文件|将错误输出重定向到一个文件中（`追加`到原有内容的后面） |命令 >> 文件
                                          2>&1或命令 &>>
                                          文件|将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）|

                                          - 即 `>` 表示覆盖 `>>` 表示追加

                                          ---

                                          - 对于重定向中的标准输出模式，可以省略文件描述符 1 不写，而错误输出模式的文件描
                                          述符 2 是必须要写的

                                          ---

                                          - 通过标准输出重定向将 man bash 命令原本要输出到屏 幕的信息写入到文件 readme.txt
                                          中，然后显示 readme.txt 文件中的内容

                                          ```bash
                                          man bash > read.txt
                                          cat read.txt
                                          ```

                                          ---

                                          - 接下来尝试输出重定向技术中的覆盖写入与追加写入这两种不
                                          同模式带来的变化。首先通过覆盖写入模式向 readme.txt
                                          文件写入多行数据（该文件中已包含 上一个实验的 man
                                          命令信息）。需要注意的是，_在通过覆盖写入模式向文件中写入数据时，每
                                          一次都会覆盖掉上一次写入的内容，所以最终文件中只有最后一次的写入结果_

                                          ```bash
                                          echo hello > readme.txt
                                          ```

                                          ---

                                          - 再通过追加写入模式向 readme.txt 文件写入一次数据

                                          ```bash
                                          echo Bye >> readme.txt
                                          ```

                                          ---

                                          - 虽然都是输出重定向技术，但是命令的标准输出和错误输出还是有区别的。例如查看当
                                          前目录中某个文件的信息，这里以 readme.txt
                                          文件为例。由于这个文件是真实存在的，因此
                                          使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然会把
                                          信息输出到屏幕上。
                                          - 想要把错误输出写入文件 则加上文件描述符`2`即可

                                          ```bash
                                          ls -l xxxx 2 > error.txt
                                          ```

                                          - 这个操作会特别有用，而且特别实用，因为它可以把整个脚本执行过程中的报错信
                                          息都记录到文件中，便于安装后的排错工作。

                                          ---

                                          - 当我们不区分标准输出和错误输出时，可以用文件描述符`&`

                                          ```bash
                                          ls -l xxx &>> readme.txt
                                          man man &>> readme.txt
                                          ```

## 3.2 管道符 |

                                          - 管道命令符的作用也可以用一句话概括为“把前一个命令原本要输出到屏幕的信息当做后一个命令的标准输入”。

                                          - 在 2.6 节讲解 grep 文本搜索命令时，我们通过匹配关键词/sbin/nologin 找出
                                          了所有被限制登录系统的用户。在学完本节内容后，完全可以把下面这两条命令合并为一条：

                                          ➢ 找出被限制登录用户的命令是 grep /sbin/nologin /etc/passwd；

                                          ➢ 统计文本行数的命令则是 wc –l。

                                          ```bash
                                          grep /sbin/nologin/etc/passwd | wc -l
                                          ```

                                          - 下述命令将显示系统中所有与 bash 相关的进程信息，并同时将输出到屏幕和文件中：

                                          ```bash
                                          pa aux | grep bash | tee result.txt
                                          ```

## 3.3 命令行的通配符

                                          - 顾名思义，通配符就是通用的匹配信息的符号

                                          | 通配符      | 含义           |
                                          | ----------- | -------------- |
                                          | \*          | 任意字符       |
                                          | ?           | 单个任意字符   |
                                          | [a-z]       | 单个小写字母   |
                                          | [A-Z]       | 单个大写字母   |
                                          | [a-Z]       | 单个字母       |
                                          | [0-9]       | 单个数字       |
                                          | [[:alpha:]] | 任意字母       |
                                          | [[:upper:]] | 任意大写字母   |
                                          | [[:lower:]] | 任意小写字母   |
                                          | [[:digit:]] | 所有数字       |
                                          | [[:alnum:]] | 任意字母加数字 |
                                          | [[:punct:]] | 标点符号       |

                                          - 除了使用[0-9]来匹配 0～9 之间的单个数字，也可以用[135]这样的方式仅匹配这 3
                                          个指 定数字中的一个；若没有匹配到数字 1 或 2 或 3，则不会显示出来
                                          - 通配符不一定非要放到最后面，也可以放到前面。
                                          - 通配符不仅可用于搜索文件或代替被通配的字符，还可以与创建文件的命令相结合，
                                          一口气创建出好多个文件。不过在创建多个文件时，需要使用大括号，并且字段之间用逗
                                          号间隔:

                                          ```bash
                                          touch {AA,BB,CC}.conf
                                          ```

                                          - 使用通配符还可以输出一些指定的信息：

                                          ```bash
                                          echo file{1,2,3,4,5}
                                          ```

## 3.4 常用的转义字符

                                          - 为了能够更好地理解用户的表达，Shell 解释器还提供了特别丰富的转义字符来处理输入
                                          的特殊数据
                                          - 4 个最常用的转义字符如下所示。

                                          ➢ ：使反斜杠后面的一个变量变为单纯的字符。

                                          ➢ ：转义其中所有的变量为单纯的字符串。

                                          ➢ ：保留其中的变量属性，不进行转义处理。

                                          ➢ ：把其中的命令执行后返回结果。

                                          - 如果只需要某个命令的输出值，可以像`命令`这样，将命令用反引号括起来，达到预
                                          期的效果。例如，将反引号与 uname -a 命令结合，然后使用 echo 命令来查看本机的
                                          Linux 版 本和内核信息

                                          ```bash
                                          echo `uname -a`
                                          ```

                                          - 单双引号技巧：如果参数中出现了
                                          空格，就加双引号；如果参数中没有空格，那就不用加双引号。

## 重要的环境变量

                                          - 变量是计算机系统用于保存可变值的数据类型。在 Linux 系统中，变量名称一般都是大
                                          写的，命令则都是小写的，这是一种约定俗成的规范。

                                          - Linux 系统中的环境变量是用来定义系
                                          统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。可以直接通过变量
                                          名称来提取到对应的变量值。

                                          简单来说，命令在 Linux 中的执行分为 4 个步骤;

                                          第一步：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是绝对
                                          路径则直接执行，否则进入第 2 步继续判断。

                                          第二步：Linux 系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名
                                          称来替换原本的命令名称。可以用 alias
                                          命令来创建一个属于自己的命令别名，语法格式为“alias 别名=命令”。若要
                                          取消一个命令别名，则是用 unalias 命令，语法格式为“unalias 别名”。

                                          第三步：Bash 解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部
                                          的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤 4
                                          继 续处理。可以使用“type 命令名称”来判断用户输入的命令是内部命令还是外部命令

                                          第四步：：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作
                                          PATH， 可以简单地把它理解成是“解释器的小助手”，作用是告诉 Bash
                                          解释器待执行的命令可能存 放的位置，然后 Bash
                                          解释器就会乖乖地在这些位置中逐个查找。PATH 是由多个路径值组成
                                          的变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到 Bash
                                          解释器对 Linux 命令的查找。

                                          - 我们可以使用 env 命令来查看 Linux 系统中所有的环境变量

                                          Linux中最重要的几个环境变量 | 名称 | 作用 | | ---- | ---- | | HOME | 家目录 |
                                          |SHELL|用户在使用的 Shell 解释器名称 |HISTSIZE|输出的历史命令记录条数
                                          |HISTFILESIZE|保存的历史命令记录条数 |MAIL|邮件保存路径 |LANG|系统语言、语系名称
                                          |RANDOM|生成一个随机数字 |PS1|Bash 解释器的提示符
                                          |PATH|定义解释器搜索用户执行命令的路径 |EDITOR|用户默认的文本编辑器

                                          - 其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自
                                          行创建变量来满足工作需求。例如，设置一个名称为 WORKDIR
                                          的变量，方便用户更轻松地 进入一个层次较深的目录

                                          ```bash
                                          mkdir /home/workdir
                                          WORKDIR=/home/workdir
                                          cd $WORKDIR
                                          pwd
                                          ```

                                          - 但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用;如果工作需要，可以使用
                                          export 命令将其提升为`全局变量`，这样其他用户也就可以使用 它了

                                          ```bash
                                          export WORKDIR
                                          ```

                                          后续要是不使用这个变量了，则可执行 unset 命令把它取消掉：

                                          ```bash
                                          unset WORKDIR
                                          ```

                                          - 注：直接在终端设置的变量能够立即生效，但在重启服务器后就会失效，因此我们需
                                          要将变量和变量值写入到.bashrc 或者.bash_profile 文件中，以确保永久能使用它们。

# 第四章 Vim编辑器和Shell命令脚本

## 4.1 Vim

                                          | 命令         | 作用                                    |
                                          | ------------ | --------------------------------------- |
                                          | s/one/two    | 将当前光标所在行的第一个 one 替换成 two |
                                          | s/one/two/g  | 将当前光标所在行的所有 one 替换成 two   |
                                          | %s/one/two/g | 将全文中的所有 one 替换成 two           |
                                          | ?字符串      | 在文本中从下至上搜索该字符串            |
                                          | /字符串      | 在文本中从上至下搜索该字符串            |

### 4.1.1 编写简单文档

### 4.1.2 配置主机的名称

                                          为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有 IP 地址外，
                                          还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在
                                          Linux 系统中，主机名大多保存在/etc/hostname 文件中

### 4.1.4 配置网卡信息

                                          /etc/sysconfig/network-scripts 目录中（存放着网卡的配置文件）

                                          网卡 IP 地址配置的是否正确是两台服务器是否可以相互通信的前提。在 Linux 系统中，
                                          一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件

### 4.1.4 配置软件仓库

                                          /etc/yum.repos.d/目录中（该目录存放着软件仓库的配置文件）

## 4.2 编写Shell 脚本

                                          将 Shell 终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与 Linux 系
                                          统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程
                                          语言才有的控制结构特性。要想正确使用 Shell
                                          中的这些功能特性，准确下达命令尤为重要。 Shell 脚本命令的工作方式有下面两种。

                                          ➢ ：用户每输入一条命令就立即执行。

                                          ➢ ：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本 中诸多的命令。

                                          在 Shell 脚本中不仅会用到前面学习过的很多 Linux 命令以及正则表达式、管道符、数据
                                          流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所
                                          见的 Shell 脚本。

### 4.2.1 编写简单的脚本

                                          例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这
                                          个功能的脚本应该类似于下面这样;

                                          ```bash
                                          nvim example.sh
#!/bin/zsh
#For Example BY lovelyubuntu
                                          pwd
                                          ls -al
                                          ```

                                          - Shell 脚本文件的名称可以任意，但为了避免被误以为是普通文件 ,建议将 .sh
                                          后缀加上，以表示是一个脚本文件。

                                          - 在上面的这个 example.sh 脚本中实际上出现了 3
                                          种不同的元素：第一行的脚本声明（#!） 用来告诉系统使用哪种 Shell
                                          解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和
                                          某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的
                                          作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的 Linux
                                          命令了，执行：

                                          ```bash
                                          bash example.sh #也可用别的shell执行 ，例如zsh
                                          ```

                                          除了上面用 Bash 解释器命令直接运行 Shell 脚本文件外，第二种运行脚本程序的方法是
                                          通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚
                                          本文件增加执行权限即可:

                                          ```bash
                                          ./example.sh
                                          ```

### 4.2.2 接收用户的参数

                                          但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板。为了让
                                          Shell
                                          脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够
                                          像之前执行命令时那样，接收用户输入的参数。

                                          这意味着命令不仅要能接收用户输入的内容，还要有能力进行判断区别，根据不同的输
                                          入调用不同的功能。

                                          其实，Linux 系统中的 Shell 脚本语言早就考虑到了这些，已经内设了用于接收参数的变
                                          量，变量之间使用空格间隔。例如:

                                          \$0 对应的是当前 Shell 脚本程序的名称，

                                          \$#对应的是总 共有几个参数，

                                          \$\*对应的是所有位置的参数值，

                                          \$?对应的是显示上一次命令的执行返回值，

                                          $1、$2、$3……则分别对应着第 N 个位置的参数值

                                          ```bash
                                          nvim example.shell

#!/bin/bash
                                          echo "当前脚本名称为$0"
                                          echo "总共有$#个参数，分别是$*。"
                                          echo "第 1 个参数为$1，第 5 个为$5。"

                                          bash example.sh one two three four five six
                                          ```

### 4.2.3 判断用户的参数

                                          执行 mkdir 命令时会判断用户输入的信息，即判断用户
                                          指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell
                                          脚本中的条 件测试语法可以判断表达式是否成立，若条件成立则返回数字
                                          0，否则便返回非零值。条件测 试语法的执行格式如图 4-16
                                          所示。切记，**条件表达式两边均应有一个空格**。

                                          - 测试语句格式：[ 条件表达式 ]

                                          按照测试对象来划分，条件测试语句可以分为 4 种：

                                          ➢ 文件测试语句；

                                          ➢ 逻辑测试语句；

                                          ➢ 整数值比较语句；

                                          ➢ 字符串比较语句。

                                          文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的
  参数如表 4-3 所示。 | 运算符 | 作用 | |-|-|
  |-d|测试文件是否为目录类型(directory) |-e|测试文件是否存在(exist)
  |-f|判断是否为一般文件(file) |-r|测试当前用户是否有权限读取(read)
|-w|测试当前用户是否有权限写入(write) |-x|测试当前用户是否有权限执行(execute)

  - 下面使用文件测试语句来判断/etc/fstab
  是否为一个目录类型的文件，然后通过`Shell 解释 器的内设 $? 变量显示上一条命令执行后的返回值`。如果返回值为
  0，则目录存在；如果返回值 为非零的值，则意味着它不是目录，或这个目录不存在：

  ```bash
  [ -d /etc/fstab ]
  echo $?
  ```

  - 在 Shell
  终端中逻辑“与”的运算符号是&&，**它表示当前面的命令执行成功后才会执行它后面的命令**，
  因此可以用来判断~/test 文件是否存在，若存在则输出 Exist 字样。

  ```bash
  [ -e ~/test ] && echo "Exist"
  ```

  - 除了逻辑“与”外，还有逻辑“或”，它在 Linux 系统中的运算符号为||，**表示当前面的
  命令执行失败后才会执行它后面的命令**，因此可以用来结合系统环境变量 USER
  来判断当前 登录的用户是否为非管理员身份：

  ```bash
  $ echo $USER

  [ $USER = root ] || echo "user"

  su -lovelyubuntu

  [ $USER = root ] || echo "user"
  ```

  - 第三种逻辑语句是“非”，在 Linux
  系统中的运算符号是一个叹号（！），它表示把条件测
  试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；
  原本测试错误的结果，则将其变成正确的。
  - 注：叹号应该放到判断语句的前面，代表对整个的测试语句进行取反值操作

  例子：当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前
  登录用户的 USER 变量名称是否等于 root，然后用逻辑“非”运算符进行取反操作，效果就
  变成了判断当前登录的用户是否为非管理员用户。最后若条件成立，则会根据逻辑“与”运
  算符输出 user 字样；若条件不满足，则会通过逻辑“或”运算符输出 root
  字样，而只有在前 面的&&不成立时才会执行后面的||符号。

  ```bash
  [ ! $USER = root ] && echo "user" || echo "root"
  ```

  整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且 143
  不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲
  突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规
  范的整数比较运算符来进行操作。可用的整数比较运算符如表 4-4 所示。

  可用的整数比较运算符 | 运算符 | 作用 | |-|-| |-eq|是否等于 equal |-ne|是否不等于
  notequal |-gt|是否大于 greaterthan |-lt|是否小于 lessthan |-le|是否等于或小于
  lessequal |-ge|是否大于或等于 greaterequal

  ---

  - 测试一下 10 是否大于 10 以及 10 是否等于 10（通过输出的返回值 内容来判断）

  ```bash
  [ 10 -gt 10]
  echo $?

  [ 10 -eq 10]
  echo $?
  ```

  - 接下来先使用 free -m 命令查看内存使用量情况（单位为 MB），然后通过“grep
  Mem:”命令 过滤出剩余内存量的行，再用 awk '{print $4}'命令只保留第 4 列

  ```bash
  free -m | grep Mem: | awk '{print $4}'
  ```

  如果想把这个命令写入到 Shell 脚本中，那么建议把输出结果赋值给一个变量，以方便其
  他命令进行调用

  ```bash
  FreeMem=`free -m | grep Mem: | awk '{print $4}'`
  echo $FreeMem
  ```

  - 我们使用整数运算符来判断内存可用量的值是否小于 1024，若小
  于则会提示“Insufficient Memory”（内存不足）的字样

  ```bash
  [ $FreeMem -lt 1024 ] && echo "Insufficient Memory"
  ```

  ---

  - 字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来
  判断某个变量是否未被定义（即内容为空值）

  | 运算符 | 作用                   |
  | ------ | ---------------------- |
  | =      | 比较字符串内容是否相同 |
  | !=     | 比较字符串内容是否不同 |
  | -z     | 判断字符串内容是否为空 |

  - 通过判断string 变量是否为空值,进而判断是否定义了这个变量

  ```bash
  [ -z $String ]
  echo $?
  ```

  tips: $的作用是提取变量的实际值

  - 再次尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值 LANG 不是英语
  （en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样

  ```bash
  echo $LANG

  [ ! $LANG = "en.us" ] && echo ""
  ```

## 4.3 流程控制语句

  if for while case

### 4.3.1 if 条件测试语句

  单分支结构

  ```bash
  if 条件
  then 命令
  fi
  ```

  下面使用单分支的 if 条件语句来判断/media/cdrom 目录是否存在，若不存在就创建这个
  目录，反之则结束条件判断和整个 Shell 脚本的执行。

  ```bash
  nvim mkcdrom.sh

  DIR="/media/cdrom"

  if [ ! -d $DIR]
  then
  mkdir -p $DIR #-p表示递归创建
  fi
  ```

  ---

  if 条件语句的双分支结构也是一种很简单的判 断结构

  ```bash
  if 条件判断
  then 命令1
  else 命令2
  fi
  ```

  ---

  if 条件语句的多分支结构由 if、then、else、elif、fi
  关键词组成，它进行多次条件匹配判
  断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如
  果……那么……如果……那么……”。

  ```bash
  if 条件1
  then 命令1
  elif 条件2
  then
  elif
  then
  fi
  ```

### 4.3.2 for

  for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当要处理的
  数据有范围时，使用 for 循环语句就再适合不过了。

  ```bash
  for 变量名 in 取值列表
  do
  命令序列
  done
  ```

  下面使用 for 循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设
  置密码。首先创建用户名称的列表文件
  users.txt，每个用户名称单独一行。读者可以自行决定 具体的用户名称和个数：

  ```bash
  nvim users.txt
  andy
  barry
  carl
  duke
  eric
  ```

  接下来编写 Shell 脚本 addusers.sh 。在脚本中使用 read
  命令读取用户输入的密码值，然 后赋值给 PASSWD 变量，并通过-p
  参数向用户显示一段提示信息，告诉用户正在输入的内容
  即将作为账户密码。在执行该脚本后，会自动使用从列表文件 users.txt
  中获取到所有的用户名称，然后逐一使用“id
  用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成
  功，也就是判断该用户是否已经存在。

  ```bash
  nvim addusers.sh

  read -p "Enter The Users Password : " PASSWD
  for UNAME in `cat users.txt`
  do
  id $UNAME &> /dev/null
  if [ $? -eq 0 ]
  then
  echo "$UNAME , Already exists"
  else
  useradd $UNAME &> /dev/null
  echo "$PASSWD" | passwd --stdin $UNAME &>  /dev/null
  echo "$UNAME , Create success"
  fi
  done

#/dev/null 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。
  ```

  - 在 Linux 系统中，/etc/passwd 是用来保存用户账户信息的文件

### 4.3.3 while 条件循环语句

  ```bash
  while 条件测试
  do
  命令
  done
  ```

### 4.3.4 case 条件测试语句

  case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹
  配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列出的范围内，
  则会去执行星号（\*）中所定义的默认命令。case 语句的语法结构如图 4-23 所示。

  ```bash
  case 变量值 in
  模式1)
  命令
  ;;
  模式2）
  命令
  ;;
  ........
  *)
  默认命令
  esac
  ```

## 4.4 计划任务服务程序

# 第5章 用户身份和文件权限

  很多人认为，Linux 系统中的管理员就是 root。这其实是错 误的，Linux
  系统的管理员之所以是 root，并不是因为它的名字叫 root，而是因为该用户的身
  份号码即 UID（User IDentification）的数值为 0。在 Linux 系统中，UID
  就像我们的身份证号 码一样具有唯一性，因此可通过用户的 UID 值来判断用户身份。在
  RHEL 8 系统中，用户身 份有下面这些。 ➢ 管理员的UID为0：系统的管理员用户。

  ➢ 系统用户的UID为1——999：Linux 系统为了避免因某个服务程序出现漏洞而被黑客提
  权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏
  范围。

  ➢ 普通用户的UID从1000开始 ：是由管理员创建的用于日常工作的用户。

  为了方便管理属于同一组的用户，Linux 系统中还引入了用户组的概念。通过使用用户
  组号码（GID，Group
  IDentification），可以把多个用户加入到同一个组中，从而方便为组中的
  用户统一规划权限或指定任务。

  另外，在 Linux 系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且
  这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户
  组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满
  足日常的工作需要。

  - 基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组
  则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。

### 5.1.1 id命令

  id 命令用于显示用户的详细信息，语法格式为“id 用户名”。

### 5.1.2 useradd命令

  useradd 命令用于创建新的用户账户，语法格式为“useradd [参数] 用户名”。 可以使用
  useradd 命令创建用户账户。使用该命令创建用户账户时，默认的用户家目录会
  被存放在/home 目录中，默认的 Shell
  解释器为/bin/bash，而且默认会创建一个与该用户同名
  的基本用户组。这些默认设置可以根据表 5-1 中的 useradd 命令参数自行修改。 |
  parameter | function | |-|-| |-d|指定用户的家目录（默认为/home/username）
  |-e|账户的到期时间，格式为 YYYY-MM-DD |-u|指定该用户的默认 UID
  |-g|指定一个初始的用户基本组（必须已存在） |-G|指定一个或多个扩展用户组
  |-N|不创建与用户同名的基本用户组 |-s|指定该用户的默认 Shell 解释器

# 5.1.3 groupadd

  groupadd 命令用于创建新的用户组，语法格式为“groupadd [参数] 群组名”。

# 5.1.4 usermod

  usermod 命令用于修改用户的属性，英文全称为“user modify”，语法格式为“usermod [参
  数] 用户名”。

  Linux 系统中的一切都是文件，因此在系统中创建用户也就是修改配
  置文件的过程。用户的信息保存在/etc/passwd
  文件中，可以直接用文本编辑器来修改其中的 用户参数项目，也可以用 usermod
  命令修改已经创建的用户信息，比如用户的 UID、基本/扩 展用户组、默认终端等。 |
  parameter | function | |-|-| |-c|填写用户账户的备注信息 |-d -m|参数-m 与参数-d
  连用，可重新指定用户的家目录并自动把旧的数据转移过去 |-e|账户的到期时间，格式为
  YYYY-MM-DD |-g|变更所属用户组 |-G|变更扩展用户组 |-L|锁定用户禁止其登录系统
  |-U|解锁用户，允许其登录系统 |-s|变更默认终端 |-u|修改用户的 UID

### 5.1.5 passwd

  passwd 命令用于修改用户的密码、过期时间等信息，英文全称为“password”，语法格式
  为“passwd [参数] 用户名”。

### 5.1.6 userdel

  userdel 命令用于删除已有的用户账户，英文全称为“user delete”，语法格式为“userdel
  [参 数] 用户名”

## 5.2 文件权限与归属

  在 Linux
  系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来
  说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新
  增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。

  但是，对于目录 文件来说，理解其权限设置就不那么容易了。很多资深 Linux
  用户其实也没有真正搞明白。
  对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新
  增、删除、重命名文件；而“可执行”则表示能够进入该目录。

  文件的可读、可写、可执行权限的英文全称分别是 read、write、execute，可以简写为
  r、 w、x，亦可分别用数字 4、2、1
  来表示，`文件所有者`、`文件所属组`及`其他用户`权限之间无关 联
  文件权限的数字表示法基于字符（rwx）的权限计算而来，其目的是简化权限的表示方式。

  例如，若某个文件的权限为 7，则代表可读、可写、可执行（4+2+1）；若权限为
  6，则代表可
  读、可写（4+2）。我们来看一个例子。现在有这样一个文件，其所有者拥有可读、可写、可
  执行的权限，其文件所属组拥有可读、可写的权限；其他人只有可读的权限。那么，这个文
  件的权限就是 rwxrw-r--，数字法表示即为 764。

  这里以 rw-r-x-w-权限为例来介绍如何将字符表示的权限转换为数字表示的权限。首先，
  要将各个位上的字符替换为数字，如图 5-1 所示。
  减号是占位符，代表这里没有权限，在数字表示法中用 0 表示。也就是说，rw-转换后是
  420，r-x 转换后是 401，-w-转换后是 020。然后，将这 3
  组数字之间的每组数字进行相加， 得出 652，这便是转换后的数字表示权限

## 5.3 文件的特殊权限

  在复杂多变的生产环境中，单纯设置文件的 rwx 权限无法满足我们对安全和灵活性的需
  求，因此便有了 SUID、SGID 与 SBIT 的特殊权限位。这是一种对文件权限进行设置的特殊
  功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

### 5.3.1 SUID

  SUID 是一种对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥
  有`所有者的权限`（仅对拥有执行权限的二进制程序有效）。例如，所有用户都可以执行
  passwd 命令来修改自己的用户密码，而用户密码保存在/etc/shadow 文件中。仔细查看这
  个文件就会发现它的默认权限是 000，也就是说除了 root 管理员以外，所有用户都没有查
  看或编辑该文件的权限。但是，在使用 passwd 命令时如果加上 SUID 特殊权限位，就可
  让普通用户临时获得程序所有者的身份

  ```bash
  ls -l /etc/shadow

  ls -l /bin/passwd
  ```

### 5.3.2 SGID

  SGID
  特殊权限有两种应用场景：当对二进制程序进行设置时，能够让执行者临时获取`文件所属组的权限`；当对目录进行设置时，则是让目录内新创建的文件自动继承该目录原有用户组的名称。

### 5.3.3 SBIT (Sticky Bit)

  SBIT 特殊权限位可确保用户只能删除自己的文件，而
  不能删除其他用户的文件。换句话说，当对某个目录设置了 SBIT
  粘滞位权限后，那么该目录 中的文件就只能被其所有者执行删除操作了

  - 在工作中，若能善加使用特殊权限，就能实现很多巧妙的功能。使用 chmod 命令设置特
  殊权限的参数如表所示

  ---

  SUID、SGID、SBIT 特殊权限的设置参数 | parameter | function | |-|-| |u+s|设置
  SUID 权限 |u-s|取消 SUID 权限 |g+s|设置 SGID 权限 |g-s|取消 SGID 权限 |o+t|设置
  SBIT 权限 |o-t|取消 SBIT 权限

  切换回 root 管理员的身份下，在家目录中创建一个名为 linux 的新目录，随后为其设置
  SBIT 权限：

  ```bash
  exit

  cd ~
  mkdir linux
  chmod -R o+t linux/
  ls -ld linux/
  ```

  上述代码中的 o+t 参数是在一般权限已经设置完毕的前提下，又新增了一项特殊权限。

  上述代码中的 o+t 参数是在一般权限已经设置完毕的前提下，又新增了一项特殊权限。
  如果我们想将一般权限和特殊权限一起设置，有什么高效率的方法么？ 其实，SUID、SGID
  与 SBIT 也有对应的数字表示法，分别为 4、2、1。也就是说 777 还
  不是最大权限，最大权限应该是 7777，其中第 1
  个数字代表的是特殊权限位。既然知道了数
  字表示法是由“特殊权限+一般权限”构成的，现在就以上面 linux 目录的权限为例，为大家
  梳理一下计算方法。 在 rwxr-xr-t 权限中，最后一位是 t，这说明该文件的一般权限为
  rwxr-xr-x，并带有 SBIT
  特殊权限。对于可读（r）、可写（w）、可执行（x）权限的数字计算方法大家应该很熟悉
  了—rwxr-xr-x 即 755，而 SBIT 特殊权限位是 1，则合并后的结果为 1755。
  再增加点难度，如果权限是“rwsrwSr--”呢？首先不要慌，大写 S 表示原先没有执行权
  限，因此一般权限为 rwxrw-r--，将其转换为数字表示法后结果是 764。带有的 SUID 和
  SGID 特殊权限的数字法表示是 4 和 2，心算得出结果是 6，合并后的结果为 6764。

## 5.4 文件的隐藏属性

  Linux 系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏
  起来的权限，默认情况下不能直接被用户发觉

### 5.4.1 chattr命令

  chattr 命令用于设置文件的隐藏权限，英文全称为 change
  attributes，语法格式为“chattr [参 数] 文件名称”

  如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把
  某个隐藏功能移出文件，则需要追加“-参数”。chattr
  命令中可供选择的隐藏权限参数非常丰 富

  我们先来创建一个普通文件，然后立即尝 试删除（这个操作肯定会成功）：

  ```bash
  echo "for Test" > linuxprobe
  rm linuxprobe
  ```

  接下来再次新建一个普通文件，并为其设置“不允许 删除与覆盖”（+a
  参数）权限，然后再尝试将这个文件删除；

  ```bash
  echo "for Test" > linuxprob
  chattr +a linuxprobe
  rm linuxprobe
  ```

  上述操作会失败

### 5.4.2 lsattr 命令

  lsattr 命令用于查看文件的隐藏权限，英文全称为“list
  attributes”，语法格式为“lsattr [参 数] 文件名称”

## 5.5 文件访问控制列表

  不知道大家是否发现，前文讲解的一般权限、特殊权限、隐藏权限其实有一个共性—权
  限是针对某一类用户设置的，能够对很多人同时生效。如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限，更加精准地派发权限。另外，如果针对某个目录设置了
  ACL，则目录中的文件会继承其 ACL 权限；若针对文件设置了
  ACL，则文件不再继承其所在目录的 ACL 权限。

  我们先切换到普通用户，然后尝试 进入 root 管理员的家目录中。在没有针对普通用户为
  root 管理员的家目录设置 ACL 之前，其 执行结果如下所示

  ```bash
  su time
  cd /root
  exit
  ```

### 5.5.1 setfacl命令

  setfacl 命令用于管理文件的 ACL 权限规则，英文全称为“set files ACL”，语法格式为
  “setfacl [参数] 文件名称”。 ACL
  权限提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制。 使用
  setfacl 命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。
  其中，针对目录文件需要使用-R 递归参数；针对普通文件则使用-m
  参数；如果想要删除某个 文件的 ACL，则可以使用-b 参数

### 5.5.2 getfacl

  getfacl 命令用于查看文件的 ACL 权限规则，英文全称为“get files ACL”，语法格式为
  “getfacl [参数] 文件名称”。 Linux 系统中的命令就是这么又可爱又好记。想要设置
  ACL，用的是 setfacl 命令；要想 查看 ACL，则用的是 getfacl 命令。

## 5.6 su命令与sudo服务

  su 命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切
  换到其他用户，比如从 root 管理员切换至普通用户

  ```bash
  su - root
  ```

  上面的 su 命令与用户名之间有一个减号（-），这意味着完全切
  换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强
  烈建议在切换用户身份时添加这个减号（-）。

  sudo 命令用于给普通用户提供额外的权限，语法格式为“sudo [参数] 用户名”。

  visudo 命令用于编辑、配置用户 sudo 的权限文件，语法格式为“visudo [参数]”。

# 第6章 存储结构与管理硬盘

## 6.1 一切从 "/" 开始

  Linux 系统中的一切文件都是从“根”目录（/）开始的

  Linux 系统中的文件和目录名称是严格区分大小写的

  并且文件名称中不得包含斜杠（/）

  在 Linux 系统中，最常见的目录以及所对应的 存放内容如表所示。

  | 目录名称    | 应放置的文件的内容                                          |
  | ----------- | ----------------------------------------------------------- |
  | /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等               |
  | /dev        | 以文件形式存放任何设备与接口                                |
  | /etc        | 配置文件                                                    |
  | /home       | 用户主目录                                                  |
  | /bin        | 存放单用户模式下还可以操作的命令                            |
  | /lib        | 开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数 |
  | /sbin       | 开机过程中需要的命令                                        |
  | /media      | 用于挂载设备文件的目录                                      |
  | /opt        | 放置第三方的软件                                            |
  | /root       | 系统管理员的家目录                                          |
  | /srv        | 一些网络服务的数据文件目录                                  |
  | /tmp        | 任何人均可使用的“共享”临时目录                              |
  | /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等      |
  | /usr/local  | 用户自行安装的软件                                          |
  | /usr/sbin   | Linux 系统开机时不会使用到的软件/命令/脚本                  |
  | /usr/share  | 帮助与说明文件，也可放置共享文件                            |
  | /var        | 主要存放经常变化的文件，如日志                              |
  | /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里        |

## 6.2 物理设备的命名规则

  分析一下/dev/sda5 这个设备文件名称包含哪些信息

  首先，/dev/目录中保存的应当是硬件设备文件；其次，sd 表示的是存储设备；然后，a
  表示系统中同类接口中第一个被识别到的设备；最后，5
  表示这个设备是一个逻辑分区。一言
  以蔽之，“/dev/sda5”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为 5
  的 逻辑分区的设备文件”

## 6.3 文件系统与数据资料

  文件系统的作用是合理规划硬盘，以保证用户正常的使用需求

  Linux 系统支持数十种文件系统，而最常见的文件系统如下所示。

  ➢ Ext2 ：最早可追溯到 1993 年，是 Linux 系统的第一个商业级文件系统，它基本沿袭
  了 UNIX 文件系统的设计标准。但由于不包含日志读写功能，数据丢失的可能性很大，
  因此大家能不用就不用，或者顶多建议用于 SD 存储卡或 U 盘。

  ➢ Ext3 ：是一款日志文件系统，它会把整个硬盘的每个写入动作的细节都预先记录下来，
  然后再进行实际操作，以便在发生异常宕机后能回溯追踪到被中断的部分。Ext3 能够在
  系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当
  硬盘容量较大时，所需的修复时间也会很长，而且也不能 100%地保证资料不会丢失。

  ➢ Ext4：Ext3 的改进版本，作为 RHEL 6 系统中默认的文件管理系统，它支持的存储容
  量高达 1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4 文件系
  统能够批量分配 block（块），从而极大地提高了读写效率。现在很多主流服务器也会
  使用 Ext4 文件系统。

  ➢ XFS：是一种高性能的日志文件系统，而且是 RHEL 7/8 中默认的文件管理系统。它
  的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大
  的日志功能只需花费极低的计算和存储性能。它支持的最大存储容量为 18EB，这几
  乎满足了所有需求。

## 6.4 挂载硬件设备

### 6.4.1 mount 命令

  mount 命令用于挂载文件系统，格式为“mount 文件系统 挂载目录”

  mount 中的-a 参数会在执行后自动检查/etc/fstab
  文件中有无被疏漏挂载的设备文件，如果有，则进行自动挂载操作。

### 6.4.2 df命令

  df 命令用于查看已挂载的磁盘空间使用情况，英文全称为“disk free”，语法格式为 “df
  -h”。

### 6.4.3 umount 命令

  umount 命令用于卸载设备或文件系统，英文全称为“un mount”，语法格式为“umount [设
  备文件/挂载目录]”。

## 6.5 添加硬盘设备

### 6.5.1 fdisk 命令

  fdisk 命令用于新建、修改及删除磁盘的分区表信息，英文全称为“format disk”，语法格
  式为“fdisk 磁盘名称”。

  在 Linux 系统中，管理硬盘设备最常用的方法就当属 fdisk 命令了。它提供了集添加、删
  除、转换分区等功能于一身的“一站式分区服务”。

### 6.5.2 du 命令

  du 命令用查看分区或目录所占用的磁盘容量大小，英文全称为“disk usage”，语法格式
  为“du -sh 目录名称”。 在 Linux 系统中可以使用 du -sh /\*命令来查看在 Linux
  系统根目录下所有一级目录分别 占用的空间大小，在 1s
  之内就能找到哪个目录占用的空间最多：

  ```bash
  du -sh /*
            ```

            使用 mount 命令挂载的设备文
            件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入配置文件中

## 6.6 添加交换分区

交换（SWAP）分区是一种通过在硬盘中预先划分一定的空间，然后把内存中暂时不常
用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其
设计目的是为了解决真实物理内存不足的问题。通俗来讲就是让硬盘帮内存分担压力。但由
于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的
物理内存耗尽后才会调用交换分区的资源。

## 6.7 磁盘容量配额

本书在前面曾经讲到，Linux 系统的设计初衷就是让许多人一起使用并执行各自的任务，
从而成为多用户、多任务的操作系统。但是，硬件资源是固定且有限的，如果某些用户不断
地在 Linux
系统上创建文件或者存放电影，硬盘空间总有一天会被占满。针对这种情况，root
管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用
的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用
quota
技术进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota
技术还有软限制和硬限制的功能。

### 6.7.1 xfs\_ quofa 命令

xfs_quota 命令用于管理设备的磁盘容量配额，语法格式为“xfs_quota [参数] 配额 文件
系统”。 这是一个专门针对 XFS 文件系统来管理 quota
磁盘容量配额服务而设计的命令。其中， -c 参数用于以参数的形式设置要执行的命令；-x
参数是专家模式，让运维人员能够对 quota 服务进行更多复杂的配置。

### 6.7.2 edquota 命令

edquota 命令用于管理系统的磁盘配额，英文全称为“edit quota”，语法格式为“edquota
[参 数] 用户名”。

## 6.8 VDO（虚拟数据优化）

VDO（Virtual Data Optimize，虚拟数据优化）是一种通过压缩或删除存储设备上的数据
来优化存储空间的技术。

## 6.9 软硬方式链接

Linux 系统中的“快捷方式”。在 Windows 系统中，快捷方式就是指向原始文件的一个链
接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方，
会导致链接文件失效。但是，这个看似简单的东西在 Linux 系统中可不太一样。Linux
系统中存在软链接和硬链接两种不同的类型。

➢软链接：也叫符号链接（symbolic link），仅仅包含所链接文件的名称和路
径，很像一个记录地址的标签。当原始文件被删除或移动后，新的链接文件也会随之
失效，不能被访问。可以针对文件、目录设置软链接，跨文件系统进行链接也不是问
题。从这一点来看，它与 Windows 系统的“快捷方式”具有一样的性质。

➢硬链接：可以将它理解为一个“指向原始文件 block 的指针”，系统会创
建出一个与原来一模一样的 inode 信息块。所以，硬链接文件与原始文件其实是一模
一样的，只是名字不同。每添加一个硬链接，该文件的 inode 个数就会增加 1；而且
只有当该文件的 inode 个数为 0 时，才算彻底将它删除。换言之，由于硬链接实际上
是指向原文件 block 的指针，因此即便原始文件被删除，依然可以通过硬链接文件来
访问。需要注意的是，由于技术的局限性，不能跨分区对目录文件进行硬链接。用户
访问硬链接的效果如图 6-16 所示

### ln命令

ln 命令用于创建文件的软硬链接，英文全称为“link”，语法格式为“ln [参数]原始文件 名
链接文件名”。 ln 命令的可用参数以及作用如表 6-8 所示。在使用 ln
命令时，是否添加-s 参数，将创建 出性质不同的两种“快捷方式”： | parameter |
function | |-|-| |-s|创建“符号链接”（如果不带-s 参数，则默认创建硬链接）
|-f|强制创建文件或目录的链接 |-i|覆盖前先询问 |-v|显示创建链接的过程

  ```bash
  echo "Welcome to linuxprobe.com" > old.txt
  ln -s old.txt new.txt
  cat old.txt
  cat new.txt
  ls -l old.txt
  ```

  删除原始文件之后，新文件就立刻无法读取了

  接下来针对原始文件 old 创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建
  了一个指针。这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会
  因为原始文件的删除而导致无法读取了。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了
  2。

  ```bash
  echo "Welcome to linuxprobe.com" > old.txt
  ln old.txt new.txt
  cat old.txt
  cat new.txt
  ls -l old.txt
  ```

  这是一个非常有意思的现象。创建的硬链接文件竟然会让文件属性第二列的数字变成了
  2，这个数字表示的是文件的 inode 信息块的数量。即便删
  除了原始文件，新的文件也会一如既往地可以读取，因为只有当文件 inode
  数量被“清零”时， 才真正代表这个文件被删除了。

# 第7章 使用 RAID 与 LVM 磁盘阵列技术

  在学习了第 6 章讲解的硬盘设备分区、格式化、挂载等知识后，本章将深入讲解各个常 用
  RAID（Redundant Array of Independent
  Disks，独立冗余磁盘阵列）技术方案的特性，并通 过实际部署 RAID 10、RAID
  5+备份盘等方案来更直观地查看 RAID 的强大效果，以便进一步
  满足生产环境对硬盘设备的 IO
  读写速度和数据冗余备份机制的需求。同时，考虑到用户可能
  会动态调整存储资源，本章还将介绍 LVM（Logical Volume
  Manager，逻辑卷管理器）的部署、
  扩容、缩小、快照以及卸载删除的相关知识。相信读者在学完本章内容后，可以在企业级生
  产环境中灵活运用 RAID 和 LVM 来满足对存储资源的高级管理需求。

## 7.1 RAID（独立冗余磁盘阵列）

### 7.1.1 RAID0

  RAID 0 技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成
  一个大的卷组，并将数据依次写入各个物理硬盘中。这样一来，在最理想的状态下，硬盘设
  备的读写性能会提升数倍，但是若任意一块硬盘发生故障，将导致整个系统的数据都受到破
  坏。通俗来说，RAID 0
  技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错 误修复能力

  ![image-20230501143204498](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501143204498.png)

### 7.1.2 RAID 1

  尽管 RAID 0 技术提升了硬盘设备的读写速度，但它是将数据依次写入到各个物理硬盘
  中。也就是说，它的数据是分开存放的，其中任何一块硬盘发生故障都会损坏整个系统的数
  据。因此，如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，
  就需要用到 RAID 1 技术了。 在图 7-2 所示的 RAID 1
  技术示意图中可以看到，它是把两块以上的硬盘设备进行绑定，
  在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当
  其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。

  考虑到在进行写入操作时因硬盘切换带来的开销，因此 RAID 1 的速度会比 RAID 0 有微
  弱地降低。但在读取数据的时候，操作系统可以分别从两块硬盘中读取信息，因此理论读取
  速度的峰值可以是硬盘数量的倍数。另外，平时只要保证有一块硬盘稳定运行，数据就不会
  出现损坏的情况，可靠性较高。

  RAID 1 技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数
  据，因此硬盘设备的利用率得以下降。从理论上来说，图 7-2
  所示的硬盘空间的真实可用率 只有 50%，由 3 块硬盘设备组成的 RAID 1
  磁盘阵列的可用率只有 33%左右；以此类推。而
  且，由于需要把数据同时写入到两块以上的硬盘设备，这无疑也在一定程度上增大了系统计
  算功能的负载。

  ![image-20230501143405271](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501143405271.png)

### 7.1.3 RAID 5

  如图 7-3 所示，RAID5 技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。
  RAID 5
  磁盘阵列中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除
  自身以外的其他每一块硬盘设备上。这样的好处是，其中任何一设备损坏后不至于出现致命
  缺陷。图 7-3 中 Parity 部分存放的就是数据的奇偶校验信息。换句话说，就是 RAID 5
  技术实
  际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试
  重建损坏的数据。RAID
  这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。

  RAID 5 最少由 3 块硬盘组成，使用的是硬盘切割（Disk Striping）技术。相较于 RAID 1
  级别，好处就在于保存的是奇偶校验信息而不是一模一样的文件内容，所以当重复写入某个
  文件时，RAID 5
  级别的磁盘阵列组只需要对应一个奇偶校验信息就可以，效率更高，存储成
  本也会随之降低。

  ![image-20230501143449779](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501143449779.png)

### 7.1.4 RAID 10

  RAID 5 技术是出于硬盘设备的成本问题对读写速度和数据的安全性能有了一定的妥协，
  但是大部分企业更在乎的是数据本身的价值而非硬盘价格，因此在生产环境中主要使用
  RAID 10 技术。 顾名思义，RAID 10 技术是 RAID 1+RAID 0 技术的一个“组合体”。如图
  7-4 所示，RAID 10 技术需要至少 4 块硬盘来组建，其中先分别两两制作成 RAID 1
  磁盘阵列，以保证数据的安 全性；然后再对两个 RAID 1 磁盘阵列实施 RAID 0
  技术，进一步提高硬盘设备的读写速度。这
  样从理论上来讲，只要坏的不是同一阵列中的所有硬盘，那么最多可以损坏
  50%的硬盘设备而 不丢失数据。由于 RAID 10 技术继承了 RAID 0 的高读写速度和 RAID 1
  的数据安全性，在不 考虑成本的情况下 RAID 10 的性能也超过了 RAID
  5，因此当前成为广泛使用的一种存储技术。

  ![image-20230501143516514](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501143516514.png)

  - 由于 RAID 10 是由 RAID 1 和 RAID 0 组成的，因此正确的叫法是“RAID 一零”，
  而不是“RAID 十”。

  仔细查看图 7-4 可以发现，RAID 10 是先对信息进行分割，然后再两两一组制作镜像。
  也就是先将 RAID 1 作为最低级别的组合，然后再使用 RAID 0 技术将 RAID 1
  磁盘阵列组合 到一起，将它们视为“一整块”硬盘。而 RAID 01
  则相反，它是先将硬盘分为两组，然后使 217 用 RAID 0
  作为最低级别的组合，再将这两组 RAID 0 硬盘通过 RAID 1 技术组合到一起。 RAID 10
  技术和 RAID 01 技术的区别非常明显。在 RAID 10 中，任何一块硬盘损坏都不
  会影响到数据安全性，其余硬盘均会正常运作。但在 RAID 01
  中，只要有任何一块硬盘损坏， 最低级别的 RAID 0
  磁盘阵列马上会停止运作，这可能造成严重隐患。所以 RAID 10 远比 RAID 01
  常见，很多主板甚至不支持 RAID 01。

### 7.1.5 部署磁盘阵列

### 7.1.6 损坏磁盘阵列及修复

### 7.1.7 磁盘阵列+备份盘

### 7.1.8 删除磁盘阵列

## 7.2 LVM（逻辑卷管理器）

### 7.2.1 部署逻辑卷

### 7.2.2 扩容逻辑卷

### 7.2.3 缩小逻辑卷

### 7.2.4 逻辑卷快照

### 7.2.5 删除逻辑卷

# 第8章 使用 iptables 与 firewalld 防火墙

# 第9章 使用 ssh 服务管理远程主机

## 9.1 配置网络服务

### 9.1.1 配置网卡参数

### 9.1.2 创建网络会话

  RHEL 和 CentOS 系统默认使用 NetworkManager
  来提供网络服务，这是一种动态管理网络配
  置的守护进程，能够让网络设备保持连接状态。可以使用 nmcli
  命令来管理NetworkManager 服务程 序。nmcli
  是一款基于命令行的网络配置工具，功能丰富，参数众多。它可以轻松地查看网络信息
  或网络状态：

  ```bash
  nmcli connection show

  nmcli connection show wlan0
  ```

### 9.1.3 绑定两块网卡

## 9.2 远程控制服务

  SSH（Secure Shell）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理
  285 Linux 系统的首选方式。在此之前，一般使用 FTP 或 Telnet
  来进行远程登录。但是因为它们
  以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易受到黑客发起的中
  间人攻击，轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。 想要使用SSH
  协议来远程管理 Linux 系统，则需要配置部署 sshd 服务程序。sshd 是基于SSH
  协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：

  ➢ 基于密码的验证——用账户和密码来验证登录；

  ➢ 基于密钥的验证——需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，
  并与服务器中的公钥进行比较；该方式相较来说更安全。

  前文曾多次强调“Linux 系统中的一切都是文件”，因此在 Linux 系统中修改服务程序的
  运行参数，实际上就是在修改程序配置文件的过程。 sshd 服务的配置信息保存在
  /etc/ssh/sshd_config文件中。运维人员一般会把保存着最主要配置信息的文件称为主配置文件，
  而配置文件中有许多以井号（#）开头的注释行，要想让这些配置参数生效，需要在修改参数
  后再去掉前面的井号。sshd 服务配置文件中包含的重要参数如表 9-1 所示。

  ![image-20230501144922943](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501144922943.png)

### 9.2.2 安全密钥验证

### 9.2.3 远程传输命令

## 9.3 不间断会话服务

  Terminal Multiplexer（终端复用器，简称为
  Tmux）是一款能够实现多窗口远程控制的开源
  服务程序。简单来说就是为了解决网络异常中断或为了同时控制多个远程终端窗口而设计的程
  序。用户还可以使用 Tmux 服务程序同时在多个远程会话中自由切换，能够实现如下功能

### 9.3.1 管理远程会话

## 9.4 检索日志信息

  Linux
  系统拥有十分强大且灵活的日志系统，用于保存几乎所有的操作记录和服务运行状态，
  并且按照“报错”“警告”“提示”和“其他”等标注进行了分类。运维管理员可以根据所需的信
  息进行检索，快速找出想要的信息，因此对于了解系统运行状态有着不错的帮助作用。 在
  RHEL 8 系统中，默认的日志服务程序是 rsyslog。可以将 rsyslog 理解成之前的 syslogd
  服务的增强版本，它更加注重日志的安全性和性能指标。为了便于日后的检索，不同的日志
  信息会被写入到不同的文件中。在 Linux 系统中，常见的日志文件如表 9-7 所示。

  ![image-20230501145123514](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230501145123514.png)

  在日常工作中，/var/log/message 这个综合性的文件用得最多。在处理 Linux 系统中出
  现的各种故障时，一般是最先发现故障的症状，而找到故障的原因则一定离不开日志信息
  的帮忙。

  从理论上讲，日志文件分为下面 3 种类型。

  ➢系统日志 ：主要记录系统的运行情况和内核信息。

  ➢用户日志 ：主要记录用户的访问信息，包含用户名、终端名称、登入及退出时间、来 源
  IP 地址和执行过的操作等。

  ➢程序日志 ：稍微大一些的服务一般都会保存一份与其同名的日志文件，里面记录着服务

  每个稍微大一些的服务都有自己独立的日志文件，为了让用户在检索信息时
  不至于特别麻烦，journalctl 命令应运而生。journalctl
  命令用于检索和管理系统日志信息，英 文全称为“journal
  control”，语法格式为“journalctl 参数”。它可以根据事件、类型、服务名
  称等信息进行信息检索，从而大大提高了日常排错的效率。journalctl
  命令的常见参数如表 9-8 所示。大家可以先混个脸熟，然后再开始实验。

  | 参数         | 作用                 |
  | ------------ | -------------------- |
  | -k           | 内核日志             |
  | -b           | 启动日志             |
  | -u           | 指定服务             |
  | -n           | 指定条数             |
  | -p           | 指定类型             |
  | -f           | 实时刷新（追踪日志） |
  | --since      | 指定时间             |
  | --disk-usage | 占用空间             |

  首先查看系统中最后 5 条日志信息：

  ```bash
  journalctl -n 5
  ```

  还可以使用-f 参数实时刷新日志的最新内容:

  ```bash
  journalctl -f
  ```

  在 rsyslog 服务程序中，日志根据重要程度被分为 9 个等级，如表 9-9
  所示。这样的好处
  是，我们可以直击最重要的信息，而不用担心会被海啸般的输出内容所淹没。大家可以将表
  9-9 留存，以备日后工作中进行查阅。

  | 日志等级 | 说明                                           |
  | -------- | ---------------------------------------------- |
  | emerg    | 系统出现严重故障，比如内核崩溃                 |
  | alert    | 应立即修复的故障，比如数据库损坏               |
  | crit     | 危险性较高的故障，比如硬盘损坏导致程序运行失败 |
  | err      | 危险性一般的故障，比如某个服务启动或运行失败   |
  | warning  | 警告信息，比如某个服务参数或功能出错           |
  | notice   | 不严重的一般故障，只是需要抽空处理的情况       |
  | info     | 通用性消息，用于提示一些有用的信息             |
  | debug    | 调试程序所产生的信息                           |
  | none     | 没有优先级，不进行日志记录                     |

  如果只想看系统中较高级别的报错信息，可以在 journalctl 命令中用-p 参数进行指定：

  ```bash
  journalctl -p crit
  ```

  我们不仅能够根据日志等级进行检索，还可以用--since 参数按照今日（today）、近 N 小
  时（hour）、指定时间范围的格式进行检索，找出最近的日志数据。来看下面几个例子。

  仅查询今日的日志信息：

  ```bash
  journalctl --since today
  ```

  仅查询最近 1 小时的日志信息：

  ```bash
  journalctl --since "12:00" --until "14:00"
  ```

  仅查询从 2020 年 7 月 1 日至 2020 年 8 月 1 日的日志信息：

  ```bash
  journalctl --since "2020-07-01" --until "2020-08-01"
  ```

  下面我们来看个不一样的：查询指定服务的日志信息。在默认情况下，所有的日志信息
  都是混在一起的。如果想看具体某项服务的日志信息，可以使用\_SYSTEMD_UNIT 参数进行
  查询，服务名称的后面要有“.service”，这是标准服务名称的写法。

  ```bash
  journalctl -u sshd
  ```

# 第10章 使用Apache 服务部署静态网站

# 第11章 使用vsftpd 服务传输文件

# 第12章 使用Samba或NFS实现文件共享

# 第13章 使用BIND提供域名解析服务

# 第 14 章 使用DHCP动态管理主机地址

## 14.1 动态主机配置协议

  动态主机配置协议（DHCP）是一种基于 UDP 协议且仅限于在局域网内部使用的网络协
  议，主要用于大型的局域网环境或者存在较多移动办公设备的局域网环境中，用途是为局域
  网内部的设备或网络供应商自动分配 IP 地址等参数，提供网络配置的“全家桶”服务。
  简单来说，DHCP 就是让局域网中的主机自动获得网络参数的服务。自动分配，闲置回收。

## 14.2 部署 dhcpd 服务程序

  dhcpd 是 Linux 系统中用于提供 DHCP 的服务程序

  安装 dhcpd 服务程序，其软件包名称为 dhcp-server

  ```bash
  cat /etc/dhcp/dhcpd.conf
  ```

  dhcp 的服务程序的配置文件中只有 3 行注释语句，这意味着我们需 要自行编写这个文件

  ![image-20230502160145817](https://cdn.jsdelivr.net/gh/MEProtoss/cloudimg/My%20Collectionsimage-20230502160145817.png)

## 14.3 自动管理 IP 地址

  DHCP 的设计初衷是为了更高效地集中管理局域网内的 IP 地址资源。DHCP 服务器会自
  动把 IP 地址、子网掩码、网关、DNS
  地址等网络信息分配给有需要的客户端，而且当客户端
  的租约时间到期后还可以自动回收所分配的 IP 地址，以便交给新加入的客户端。

## 14.4 分配固定 IP 地址

# 第15章 使用Postfix 与Devecot 部署邮件系统

# 第16章 使用Ansible服务实现自动化运维

# 第17章 使用iSCSI服务部署网络存储

# 第18章 使用MariaDB数据库管理系统

# 第19章 使用 LNMP架构部署动态网络环境
