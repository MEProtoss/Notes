---
title: 算法
abbrlink: b7e144d1
date: 2024-05-10 21:37:57
tags:
---

## 数组

- 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。

### 704 二分查找

要注意选取的是左闭右闭的区间还是左闭右开的区间

### 27 原地移除数组中的元素

双指针思路:

- 快指针用于寻找”新“数组中的元素
- 慢指针是新数组的下标值
- 快指针遍历数组，当遇见不为val的数值（即新数组中的元素）则赋值给nums[slow]，遍历完就可得到新数组

暴力解法要注意考虑边界条件不要角标越界

###  977 有序数组的平方

- 双指针秒了

### 209 长度最小的子数组

- 暴力解法显而易见
- 滑动窗口:

所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。

滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了,此时移动左边界）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的右指针，也就是for循环里的索引。

### ⭐️54螺旋矩阵

算法思路:

1. 空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。
2. 初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。
3. 循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。
    1. 根据边界打印，即将元素按顺序添加至列表 res 尾部。
    2. 边界向内收缩 1 （代表已被打印）。
    3. 判断边界是否相遇（是否打印完毕），若打印完毕则跳出。
4. 返回值： 返回 res 即可。

### 数组章节总结

- 数组是存放在连续内存空间上的相同类型数据的集合。
- 数组下标都是从0开始的。
- 数组内存空间的地址是连续的；因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

## 链表

### 链表理论基础

Java中链表的定义

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

链表操作的两种方式：

- 直接使用原来的链表来进行删除操作。

- 设置一个虚拟头结点在进行删除操作。(推荐)
### 203 移除链表元素

设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。

- 注意遍历终止的条件是当前指针指向的节点为空

- 每一次判断之后同时移动两个指针

- 最后返回虚拟头结点的下一个节点即为新节点的头

### 707 设计链表

- 首先设计链表节点
- 然后用单链表+虚拟头结点实现需求


## 哈希表理论基础和总结

- 需要 **判断一个元素是否出现过** 或者**一个元素出现的频次**场景应该第一时间想到哈希法。

- 使用哈希表的时候注意数据结构的选择
  - 数组 : 适用于元素不是太大的情况,将数据转换成哈希数组的效率较高，建议优先使用。
  - set :转变成set需要进行hash运算，效率较低。
  - map :要存放两个元素（数值和频率）（key和value）

- 解题思路
  - 先想到用哈希表
  - 考虑用什么存储结构

### 有效的字母异位词

- 字母运算时会自动取 ASCII 码。

### 数组交集

- Java 基础回顾

```txt
在Java中，List是一个接口，它代表了一个有序的集合，允许重复的元素。List接口继承自Collection接口，它是集合框架中的一部分，用于存储一组元素，并且可以对这些元素进行访问、添加、删除和修改等操作。

Java中常用的List实现类包括：

ArrayList：基于数组实现的动态数组，支持随机访问，但在插入和删除操作时可能会涉及元素的移动。大小可以动态增长。
LinkedList：基于链表实现的双向链表，插入和删除操作性能较好，但随机访问效率较低。
Vector：与ArrayList类似，但是它是线程安全的，因此在多线程环境下使用较为安全，但性能相对较低。
List接口定义了一系列方法，包括但不限于：

int size()：返回列表中的元素数量。
boolean isEmpty()：检查列表是否为空。
boolean contains(Object o)：检查列表是否包含指定的元素。
boolean add(E e)：将指定的元素添加到列表的末尾。
void add(int index, E element)：将指定的元素插入到列表的指定位置。
E remove(int index)：移除列表中指定位置的元素。
void clear()：清空列表中的所有元素。
E get(int index)：返回列表中指定位置的元素。
E set(int index, E element)：将列表中指定位置的元素替换为指定的元素。
```

### 两数之和

- 思路：一边遍历，一边将其存入哈希表，在遍历时判断我们要找的元素之前是否出现过。

- 我们既要知道元素的值，还要知道元素的下标

- 注意：map是要存放 **遍历过** 的元素

### 四数相加

- 思路：前两个数组遍历相加，把所有的和存到一个数组A里，同时要记录出现的次数；后两个数组遍历相加，把所有的和存在一个数组B里,同时要记录出现的次数；遍历A看看想要的数在B中是否存在
- 因为既要知道数，还要统计次数，所以使用map（键值对）作为hash表的存储结构，此时key是值，value是出现的次数
- 注意：两两分组的复杂度是n^2, 一三分组是n^3。
- 每次配对成功后，count计数应该是加value里的值

### 三数相加

- 先排序
- 去重逻辑（有了再考虑去重，而不是还没有用就去考虑去重）
- 双指针解  i left right

### 四数之和

- 思路类似三数之和 i j left right
- 注意剪枝操作和去重操作

## 字符串
### 1768合并字符串
- 不可便字符序列`String`以及常用api

（1）boolean isEmpty()：字符串是否为空

（2）int length()：返回字符串的长度

（3）String concat(xx)：拼接

 （4）boolean equals(Object obj)：比较字符串是否相等，区分大小写

（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写

（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小

（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写

（8）String toLowerCase()：将字符串中大写字母转为小写

（9）String toUpperCase()：将字符串中小写字母转为大写

（10）String trim()：去掉字符串前后空白符

（11）public String intern()：结果在常量池中共享

- 可变字符序列`StringBuilder`和`StringBuffer` 前者线程不安全，后者线程安全 两者常用api一致

（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接

（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符

（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符

（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str

（5）void setCharAt(int index, char c)：替换[index]位置字符

（6）char charAt(int index)：查找指定index位置上的字符

（7）StringBuffer insert(int index, xx)：在[index]位置插入xx

（8）int length()：返回存储的字符数据的长度

（9）StringBuffer reverse()：反转

#### 解题思路

直接模拟过程就行

### 1071字符串的最大公因子






### 反转字符串

难点就在如何去除多余的空格：这其实就是删除元素的算法，需要使用**快慢指针**的方法: 快指针寻找符合要求的字母（要收集的字母）、慢指针就是来表示要更新在哪里

题目要求：

- 输入: "the sky is blue"
- 输出: "blue is sky the"
- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

解题思路：

- 将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。

所以解题思路如下：

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

### KMP算法

- 用以解决字符串匹配的问题
