---
title: Java内存区域详解
url: Java内存区域详解
date: 2024-03-28 10:13:23
tags: [Java]
excerpt: 
index_img: /img/
mermaid: false
---

<!-- markdown-toc GFM -->

* [运行时数据区域](#运行时数据区域)
  * [程序计数器](#程序计数器)
  * [Java虚拟机栈](#java虚拟机栈)
  * [本地方法栈](#本地方法栈)
  * [堆](#堆)
  * [方法区](#方法区)
    * [方法区和永久代以及元空间是什么关系呢？](#方法区和永久代以及元空间是什么关系呢)
    * [方法区常用参数有哪些？](#方法区常用参数有哪些)
  * [运行时常量池](#运行时常量池)
  * [字符串常量池](#字符串常量池)
    * [⭐️补充：](#补充)
      * [Hashtable](#hashtable)
      * [对象引用](#对象引用)
      * [符号引用](#符号引用)
    * [JDK 1.7 为什么要将字符串常量池移动到堆中？](#jdk-17-为什么要将字符串常量池移动到堆中)
  * [直接内存](#直接内存)
  * [HotSpot 虚拟机对象探秘](#hotspot-虚拟机对象探秘)
    * [对象的创建(⭐️)](#对象的创建)
    * [内存分配并发问题](#内存分配并发问题)
    * [对象的内存布局](#对象的内存布局)
    * [对象的访问定位](#对象的访问定位)

<!-- markdown-toc -->
# 运行时数据区域
  - 线程私有的(线程安全的)： 程序计数器 虚拟机栈 本地方法栈

  - 线程共享的(线程不安全)：堆 方法区 直接内存 (非运行时数据区的一部分)

## 程序计数器

  - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

  - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

  - 为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，我们称这类内存区域为“线程私有”的内存。

  - ⭐️：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域。因为它是线程私有的，每个线程都有其独立的程序计数器，它随线程的创建而创建，消亡而消亡。因此即使有大量线程同时运行，每个线程的程序计数器都是独立的，不会相互影响。

  - ⭐️：`OutOfMemoryError` 是 Java 中的一个错误类型，表示程序尝试使用更多内存而无法分配足够的内存空间，导致堆内存耗尽。这通常发生在以下情况下：

  - 内存泄漏：程序中存在内存泄漏，即一些不再被使用的对象仍然被引用，导致它们不能被垃圾回收器回收。随着时间的推移，这些对象会累积并占用大量内存，最终导致内存耗尽。

  - 内存占用过大：程序在某些时候需要处理大量数据或者创建大量对象，但是堆内存空间不足以容纳这些数据或对象，导致 `OutOfMemoryError`。

  - 过多的线程：每个线程都会占用一定的内存空间，如果程序创建了过多的线程，就会消耗大量的内存资源，最终导致堆内存耗尽。

  - 无限递归：递归调用的深度过大，导致方法调用栈溢出，进而触发 `OutOfMemoryError`。

## Java虚拟机栈

  - 栈是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡 

  - 除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的

  - 每一次方法调用都会有一个对应的`栈帧`被压入栈中，每一个方法调用结束后，都会有一个`栈帧`被弹出。

  - 栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。[栈示意图](https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png)

  - 局部变量表：存放八种基本数据类、对象引用(可理解为存放了一个指向具体值起始位置的地址指针)

  - 操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。（临时存储区）

  - ❓动态链接：该方法需要调用其他方法的时候，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接 。

  - `StackOverflowError` :函数调用出现无限循环时会占用太多内存空间，栈是存放方法的，太多方法挤进去放不下就栈内存溢出错误了。

  - Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。

  - 区别于`StackOverflowError`错误，塞满了满出来了导致错误；当栈在动态扩展内存的时候，如果无法申请足够的内存空间，会出现`OutOfMemoryError`

简单总结一下程序运行中栈可能会出现两种错误：

  - StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

  - OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

## 本地方法栈

和虚拟机栈类似，但是存储的是由native关键字修饰的方法。也会出现`StackOverFlowError`(栈溢出) 和 `OutOfMemoryError`(内存溢出错误)

## 堆

在虚拟机启动时创建,内存区域的唯一目的就是存放对象实例，几乎所有的 对象实例 以及 数组 都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
- 新生代内存(Young Generation)
- 老生代(Old Generation)
- 永久代(Permanent Generation)

下图两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

[堆内存结构](https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png)

JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存

大部分情况下，对象首先在`eden`区域分配。

一次新生代垃圾回收之后如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)
  当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。
  对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：
- java.lang.OutOfMemoryError: GC Overhead Limit Exceeded：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值。

## 方法区
### 方法区和永久代以及元空间是什么关系呢？ 
- 方法区` 和 `永久代` 以及 `元空间` 的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。[HotSpot 虚拟机方法区的两种实现](https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png)
- 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
- 永久代受制于JVM本身设置的固定大小上限，无法调整。而元空间使用本地内存，受本机可用内存限制，内存溢出的机率更小
当元空间溢出时会得到如下错误：

```java
java.lang.OutOfMemoryError: MetaSpace
```

你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。

```java
-XX：MetaspaceSize 调整标志定义元空间的初始大小,如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
```

- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了
- 合并 HotSpot 和 JRockit 的代码时 ，因为移除了永久代，JRockit 就不需要额外设置永久代的空间

### 方法区常用参数有哪些？
```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

- JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
- 与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

## 运行时常量池

  用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）

- 字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。

- 常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。
[《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释](https://oss.javaguide.cn/github/javaguide/java/jvm/symbol-reference-and-direct-reference.png)

常量池表会在类加载后存放到方法区的运行时常量池中。

## 字符串常量池
为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要为了避免字符串的重复创建

```java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```

HotSpot虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 可以简单理解为一个固定大小的HashTable ，容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。

个人总结：
- 字符串常量池用来存储字符串常量。而字符串常量是在编译时就已经确定了，在整个程序的生命周期中保持不变。
- 在java中，字符串对象是不可变的，一旦被创建，就不可更改。当创建一个字符串的时候，先去字符串常量池中找，如果有就返回常量池中字符串对象的引用。如果没有，就先创建，再返回其引用

### ⭐️补充：
#### Hashtable
在 Java 中，Hashtable 是一个用于存储键值对的数据结构，它实现了 Map 接口，类似于 HashMap。Hashtable 是线程安全的，即多个线程可以同时访问一个 Hashtable 对象而不需要额外的同步措施。
#### 对象引用
在 Java 中，对象的引用是一种特殊的数据类型，它指向内存中对象的实际位置，但我们并不能直接访问对象的内存地址。相反，我们使用对象引用来操作对象，例如调用对象的方法或访问其属性。
当我们创建一个字符串对象时，Java 会在堆内存中分配一块内存空间，并将该字符串的内容存储在这个内存空间中。然后，Java 会返回一个引用，这个引用指向堆内存中字符串对象的位置。
在程序中，我们通过这个引用来操作字符串对象，但我们不能直接访问堆内存中的对象地址。因此，字符串对象的引用是指向堆内存中字符串对象的引用，而不是直接指向内存地址。 Java 中的对象引用是一种抽象的概念，它隐藏了对象在内存中的实际位置，使程序员可以更方便地操作对象。
#### 符号引用
在Java中，符号引用（Symbolic Reference）是指在编译时或运行时使用的一种引用，它指向一个被引用的类型、方法、字段或接口。符号引用是一种抽象的引用，它并不直接指向内存中的实际数据或代码，而是通过符号的形式来表示。在Java中，编译器和运行时系统使用符号引用来定位和访问类、方法、字段等。

符号引用包含了被引用的实体的全限定名（Fully Qualified Name），但不包含具体的内存地址或偏移量等信息。在编译时，编译器会将符号引用解析成直接引用（Direct Reference），也就是包含了实际内存地址或偏移量等信息的引用，以便在运行时能够直接访问到对应的实体。

通过符号引用，Java程序可以在编译时和运行时引用其他类、方法、字段等，实现了程序的模块化、灵活性和可维护性。

### JDK 1.7 为什么要将字符串常量池移动到堆中？
JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。

主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

```plaintext
运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。
```

## 直接内存

- 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现

- 直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

- 堆外内存就是把内存对象分配在堆外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响

## HotSpot 虚拟机对象探秘

HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

### 对象的创建(⭐️)

1. 类加载检查

虚拟机在遇到一条`new`指令的时候，首先检查这个指令的参数是否能在常量池中定位到这个类的符号引用，检查这个符号引用 代表 的类是否被加载过、解析过和初始化过，如果没有，则必须先执行对应的类加载过程

2. 分配内存 

虚拟机为新对象在堆中划出一块确定大小的空间。分配方式有两种：

- 指针碰撞
  - 适用场合：堆内存规整（即没有内存碎片）的情况下。
  - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：(也就是专门用一个列表记录碎片里可用的区域，需要分配内存的时候找一块足够大的区域分配，然后更新列表的记录) 
  - 适用场合：堆内存不规整的情况下。
  - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。
而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"）。
值得注意的是，复制算法内存也是规整的。

### 内存分配并发问题

- 线程安全问题通常是由并发引起的。在多线程编程中，如果多个线程同时访问和操作共享的资源（如共享变量、对象、文件等），并且至少有一个线程会对该资源进行写操作，那么就可能会出现线程安全问题。

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
- CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
虚拟机采用 CAS 配上失败重试的方式保证更新操作的`原子性`。(假装没冲突，一直重试，知直到成功为止)
- TLAB： 预先在eden为每一个线程分配一块儿内存，为线程中的对象分配内存的时候，先用eden区的内存，不够了再用上述CAS进行内存分配

3. 初始化零值

内存分配完成后,jvm虚拟机需要对分配到的空间进行初始化,确保所有的数据都有一个初始值。这个初始值就是零值，也称为默认值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，并且程序能够访问到这些字段的数据类型所对应的零值。具体来说,Java中的基本数据类型和引用类型在分配内存后都会有默认值

4. 设置对象头
初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行init方法
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局
在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和 对齐填充 。

- 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
- 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用,Hotspot虚拟机要求对象起始地址必须是8字节整数倍，而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。

- 句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**与**对象类型数据**各自的具体地址信息。
[对象的访问定位-使用句柄](https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png)
- 直接指针:如果使用直接指针访问，reference 中存储的直接就是对象的地址。
[对象的访问定位-直接指针](https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png)

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

HotSpot虚拟机选择了直接指针的方法来使用对象，以提高性能并减少额外的开销。

